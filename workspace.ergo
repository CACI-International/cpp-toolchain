^std:

version = 1.0.1

# Step into the only directory in another directory
remove-top-dir = fn :dir -> {
    [:only] = fs:glob <| String:format "{}/*/" :dir
    :only
}

# Download a file and unarchive it
download-and-unpack = fn :url -> cache {
    [^_, :filename] = String:split / :url
    archive = seq ^[
        out = Path:join Path:new: :filename
        fs:create-dir <| Path:parent :out
        net:download :url :out
        :out
    ]
    unpacked = Path:new:
    task (String:format "fetching {} from {}" :filename :url) <| seq (fs:unarchive :archive :unpacked) :unpacked
}

llvm-url="https://github.com/llvm/llvm-project/releases/download/llvmorg-12.0.0/llvm-project-12.0.0.src.tar.xz"
llvm-src = download-and-unpack :llvm-url

build = {
    cmake-project = fn :build-args -> cache {
        build = Path:new:
        install = Path:new:
        args = {
            env = { PATH = env:get PATH }
            pwd = :build
        }
        install-prefix = String:format "-DCMAKE_INSTALL_PREFIX={}" :install
        out = seq ^[
            fs:create-dir :build
            exec ^:args cmake build-args:src ^build-args:extra-flags :install-prefix "-DCMAKE_BUILD_TYPE=Release" |>:complete
            exec ^:args cmake --build :build -- -j4 |>:complete
            exec ^:args cmake -P cmake_install.cmake |>:complete
            :install
        ]
        task (String:format "{}" build-args:message) :out
    }

    llvm = fn :message :llvm-projects :flags -> cache {
        projects = Iter:fold (fn :acc :v -> String:format "{}{};" :acc :v) "-DLLVM_ENABLE_PROJECTS=" :llvm-projects
        build-args = {
            src = Path:join (remove-top-dir :llvm-src) llvm
            extra-flags = [^:flags, :projects, "-DLLVM_TARGETS_TO_BUILD=X86;ARM;AArch64", "-DLLVM_ENABLE_ZLIB=FORCE_ON"]
            message = :message
        }
        cmake-project :build-args
    }

    compiler-rt = fn :message :flags -> cache {
        build-args = {
            src = Path:join (remove-top-dir :llvm-src) compiler-rt
            extra-flags = :flags
            message = :message
        }
        cmake-project :build-args
    }
}

target-triple = {
    arch = fn :target -> by-content <| (String:split - :target):0
    vendor = fn :target -> by-content <| (String:split - :target):1
    os = fn :target -> by-content <| (String:split - :target):2

    host = by-content {
        # Get the OS (values are "Linux", "Darwin")
        os = exec uname |>:stdout | String:from | String:trim | by-content

        # Get the architecture ("x86_64", "aarch64", etc)
        arch = exec uname -m |>:stdout | String:from | String:trim | by-content

        match (by-content :os) ^[
            Linux -> String:format "{}-unknown-linux-gnu" :arch
            Darwin -> String:format "{}-apple-macos" :arch
        ]
    }
}

use-gcc-cmake-flags = fn :toolchain-dir :target -> {
    gcc-tool = fn :toolchain-dir :target :tool -> Path:join :toolchain-dir bin <| String:format "{}-{}" :target :tool
    [
        String:format "-DCMAKE_C_COMPILER={}" <| gcc-tool :toolchain-dir :target cc
        String:format "-DCMAKE_CXX_COMPILER={}" <| gcc-tool :toolchain-dir :target c++
    ]
}

# Make toolchain binary links to the appropriate implementation (either script or binary)
prepare-toolchain = fn :dir :targets -> {
    binaries-to-keep = [
        clang
        clang++
        clang-12
        ld.lld
        ld64.lld
        lld
        llvm-ar
        llvm-as 
        llvm-size
        llvm-nm
        llvm-strip
        llvm-objcopy 
        llvm-objdump 
        llvm-cxxfilt 
        llvm-addr2line 
        llvm-symbolizer 
        llvm-strings
        llvm-readelf 
        llvm-readobj
        llvm-install-name-tool
        llvm-lipo
        clang-format 
        scan-build
    ]

    prefixed-tools = [
        clang
        clang++
        cc
        c++
        ld
        ar
        as 
        ranlib
        size
        nm
        strip
        objcopy
        objdump 
        c++filt 
        addr2line 
        strings
        readelf
        ^match target-vendor ^[
            apple -> [install_name_tool, lipo]
            _ -> []
        ]
    ]

    non-prefixed-tools = [
        clang-format 
        scan-build
    ]

    link = fn :source :target -> (exec ln -sf :source :target |>:complete)

    make-script-tools = fn :target -> {
        prefix = fn :file -> Path:join :dir bin (String:format "{}-{}" :target :file)
        Iter:map (fn :file -> link "../libexec/wut/tools.sh" (prefix :file)) :prefixed-tools
    }

    keep-binary-patterns = Iter:fold (fn :acc :v -> [^:acc, "!", -name, :v]) [] :binaries-to-keep

    [
        # Delete unusued llvm binaries
        exec find (Path:join :dir libexec wut llvm bin) ^:keep-binary-patterns ^(String:split " " "-type f -exec rm -f {} +") |>:complete
        exec find (Path:join :dir libexec wut llvm lib) ^(String:split " " "-name *.a -exec rm -f {} +") |>:complete

        # Delete headers, other than libc++ if present
        exec find (Path:join :dir libexec wut llvm include) ^(String:split " " "! -name c++ -mindepth 1 -maxdepth 1 -exec rm -rf {} +") |>:complete

        # Link the various tools into the bin directory
        Iter:map :make-script-tools :targets
        Iter:map (fn :file -> link (String:format "{}-{}" target-triple:host :file) (Path:join :dir bin :file)) :prefixed-tools
        Iter:map (fn :file -> link (Path:join .. libexec wut llvm bin :file) (Path:join :dir bin :file)) :non-prefixed-tools

        # Make a file in the toolchain that contains the host triple
        exec sh -c (String:format "echo {} > {}" target-triple:host (Path:join :dir libexec wut host)) |>:complete
    ]
}

# Merge a directory into another directory
merge-dir = fn :src :dst -> (exec sh -c (String:format "cp -rf {}/* {}" :src :dst) |>:complete)

# Archives a toolchain and installs it into the working directory
install-toolchain = fn :toolchain -> {
    [^_, :basename] = Path:split :toolchain
    out = Path:join script:dir: <| String:format "{}.tar.gz" :basename
    args = {
        pwd = Path:parent :toolchain
        env = { PATH = env:get PATH }
    }
    exec ^:args tar -czvf :out :basename |>:complete
}

test-toolchain = fn :toolchain :targets -> {
    test-target = fn :target -> {
        tool = fn :tool -> fn ^:args -> {
            kwargs = {
                env = { PATH = String:format "{}:{}" (Path:join :toolchain bin) (env:get PATH) }
                pwd = Path:join script:dir: test
            }
            prefix = match :target ^[
                () -> ""
                _ -> String:format "{}-" :target
            ]
            tool = String:format "{}{}" :prefix :tool
            exec ^:kwargs :tool ^:args |>:complete
        }
        target = match :target ^[
            () -> target-triple:host
            _ -> :target
        ]

        cc = tool cc
        c++ = tool c++
        ld = tool ld
        ar = tool ar
        ranlib = tool ranlib

        # Skip strip on arm64e: https://bugs.llvm.org/show_bug.cgi?id=50044
        strip = match (target-triple:arch :target) (arm64e -> fn ^:args -> ()) (_ -> tool strip)

        out = Path:new:
        bar.o = Path:join :out bar.o
        bar.a = Path:join :out bar.a
        foo.o = Path:join :out foo.o
        foo-lib = match (target-triple:os target-triple:host) ^[
            macos -> Path:join :out libfoo.dylib
            linux -> Path:join :out libfoo.so
        ]
        test-c = Path:join :out test-c
        test-c++ = Path:join :out test-c++

        link-flags = match (target-triple:os target-triple:host) ^[
            macos -> [-dylib]
            linux -> [-shared]
        ]
        seq ^[
            fs:create-dir :out

            # Build library
            cc -Wall -c -o :bar.o bar.c
            cc -Wall -c -o :foo.o foo.c
            ar rc :bar.a :bar.o
            ranlib :bar.a
            ld ^:link-flags -o :foo-lib :foo.o :bar.a
            strip --strip-all :foo-lib
  
            # Build C program
            cc -Wall -o :test-c main.c :foo-lib
            strip --strip-all :test-c

            # Test C++ compiler
            c++ -Wall -o :test-c++ main.cpp :foo-lib
            strip --strip-all :test-c++

            # Run tests (if correct target)
            run-tests = fn -> {
                kwargs = {
                    env = {
                        LD_LIBRARY_PATH = :out
                        DYLD_LIBRARY_PATH = :out
                    }
                }
                seq ^[
                    exec ^:kwargs :test-c |>:complete
                    exec ^:kwargs :test-c++ |>:complete
                ]
            }
            match (by-content :target) ^[
                target-triple:host -> (run-tests)
                () -> (run-tests)
                _ -> ()
            ]
            ()
        ]
    }

    # test all available targets, as well as the default host target
    Iter:map :test-target [^:targets, ()]
}

{
    download-and-unpack
    remove-top-dir
    build
    prepare-toolchain
    merge-dir
    target-triple

    command = fn :cmd ^:args -> match :cmd ^[
        build -> {
            impl = ergo (target-triple:os target-triple:host)
	        toolchain = cache <| seq ^[
                out = Path:join Path:new: <| String:format "wut-{}-{}" :version target-triple:host
                impl:build :out
                test-toolchain :out impl:targets
                :out
            ]
            install-toolchain :toolchain
        }
    ]
}
