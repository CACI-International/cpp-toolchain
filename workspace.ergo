std:import { by-content, cache, default, env, ergo-remote, exec, fs, if, match, net, optional, source, task } = :std
std:import { Array, Bool, Iter, Map, MapEntry, Path, String } = :std

version = 5.0.0rc1

llvm-version = 15.0.0

wipal = ergo-remote "https://lgs-gitlab.redacted.invalid/api/v4/projects/^(std:net:url-encode wipal/tools/ergo-wipal)/repository/archive.tar.gz?sha=0.17.7"

llvm-url = "https://github.com/llvm/llvm-project/releases/download/llvmorg-^(llvm-version)/llvm-project-^(llvm-version).src.tar.xz"
Array:Of :Path |> :llvm-patches = Array:from <| Iter:map fs:track <| wipal:glob patches/*
llvm-src = cache {
    dir = task "downloading LLVM" <| net:unarchive ^enter :llvm-url
    # sequentially apply patches
    ^Array:from <| Iter:map (fn :patch -> {
        task "applying LLVM patch ^(Path:name :patch)" <| exec ^{pwd = :dir} (env:path-search patch) -p1 -i :patch |>:complete
    }) :llvm-patches
    :dir
}

llvm-tools = [
    llvm-ar
    llvm-ranlib
    llvm-size
    llvm-nm
    llvm-strip
    llvm-objcopy
    llvm-objdump
    llvm-cxxfilt
    llvm-addr2line
    llvm-strings
    llvm-symbolizer
    llvm-cov

    # Linux tooling, but may be useful on macOS
    llvm-readelf
    llvm-readobj

    # Apple tooling, but may be useful on Linux
    llvm-install-name-tool
    llvm-lipo
    llvm-libtool-darwin,
    llvm-otool
]

build = {
    cmake-project = fn :build-args -> cache {
        # This is a bit of a hack.
        # On linux, we're usually running through docker, so just use the system CMake etc.
        # On macOS, pull CMake from conda.
        #
        # I would use conda everywhere, except LLDB requires liblzma, which would need to be added to the sysroot.
        cmake-path = match env:os [
            macos -> {
                conda-env = wipal:conda:make-env {}
                conda-env:run install cmake make
                "^(Path:join conda-env:path bin):"
            }
            _ -> ""
        ]

        # Invoke CMake
        build = Path:new ()
        install = Path:new ()
        args = {
            env = { PATH = "^(cmake-path)^(env:get PATH)" }
            pwd = :build
        }
        out = {
            fs:create-dir :build
            exec ^:args cmake build-args:src ^build-args:extra-flags "-DCMAKE_INSTALL_PREFIX=^(:install)" "-DCMAKE_BUILD_TYPE=Release" |>:complete
            exec ^:args cmake --build :build -- -j16 |>:complete
            exec ^:args cmake -P cmake_install.cmake |>:complete
            :install
        }
        task (String:format "{}" build-args:message) :out
    }

    llvm = fn :message :llvm-projects :flags -> cache {
        projects = Iter:fold (fn :acc :v -> String:format "{}{};" :acc :v) "-DLLVM_ENABLE_PROJECTS=" :llvm-projects
        build-args = {
            src = Path:join :llvm-src llvm
            extra-flags = [
                ^:flags
                :projects
                "-DCLANG_REPOSITORY_STRING=wipal-universal-toolchain"
                "-DLLVM_TARGETS_TO_BUILD=X86;ARM;AArch64;NVPTX"
                "-DLLVM_ENABLE_ZLIB=FORCE_ON"
                "-DLLVM_INSTALL_BINUTILS_SYMLINKS=ON"
                "-DLLVM_INSTALL_CCTOOLS_SYMLINKS=ON"
                "-DLLVM_TOOLCHAIN_TOOLS=^(String:join ";" :llvm-tools)"
                "-DLLVM_TOOLCHAIN_ONLY=ON"
            ]
            message = :message
        }
        cmake-project :build-args
    }

    compiler-rt = fn :message :flags -> cache {
        build-args = {
            src = Path:join :llvm-src compiler-rt
            extra-flags = :flags
            message = :message
        }
        cmake-project :build-args
    }

    openmp = fn :message :flags -> cache {
        build-args = {
            src = Path:join :llvm-src openmp
            extra-flags = :flags
            message = :message
        }
        cmake-project :build-args
    }
}

target-triple = {
    arch = fn :target -> (String:split - :target):0
    vendor = fn :target -> (String:split - :target):1
    os = fn :target -> (String:split - :target):2

    host = {
        triple = match env:os [
            linux -> String:format "{}-unknown-linux-gnu" env:arch
            macos -> String:format "{}-apple-macos" (match env:arch [aarch64 -> arm64, :a -> :a])
        ]
 
        std:log:info <| String:format "Detected host triple: {}" :triple    
        
        :triple
    }
}

use-gcc-cmake-flags = fn :toolchain-dir :target -> {
    gcc-tool = fn :toolchain-dir :target :tool -> Path:join :toolchain-dir bin <| String:format "{}-{}" :target :tool
    [
        String:format "-DCMAKE_C_COMPILER={}" <| gcc-tool :toolchain-dir :target cc
        String:format "-DCMAKE_CXX_COMPILER={}" <| gcc-tool :toolchain-dir :target c++
    ]
}

# Make toolchain binary links to the appropriate implementation (either script or binary)
prepare-toolchain = fn :dir :targets -> {
    prefixed-tools = [
        clang
        clang++
        cc
        c++
        ld
        clang-tidy
    ]

    no-link-tools = [
        ld.lld
        ld64.lld
        "clang-^(String:split . :llvm-version |>:0)"
        clang-cpp
        clang-cl
    ]

    link = fn :source :target -> (exec ln -sf :source :target |>:complete)

    # Copy prefixed tools
    Iter:map (fn :file -> {
        tools.sh = Path:join (std:source:dir ()) (target-triple:os target-triple:host) tools.sh
        fs:copy :tools.sh <| Path:join :dir bin :file
        Iter:map (fn :target -> fs:copy :tools.sh <| Path:join :dir bin "^(:target)-^(:file)") :targets
    }) :prefixed-tools

    # Link the rest of the tools
    # Merge each command into this map to enforce they run in order, to avoid opening too many files simultaneously
    ^Array:from <| Iter:map (fn :file -> {
        source = Path:join .. <| Path:relative :dir :file
        target = Path:join :dir bin <| Path:name :file
        if (Bool:not <| fs:exists :target) (link :source :target)
    }) <| std:fs:glob "^dir/libexec/wut/llvm/bin/*"

    # Delete tools that shouldn't be linked
    Iter:map (fn :tool -> fs:remove (Path:join :dir bin :tool)) :no-link-tools

    # Delete unusued llvm libraries
    exec find (Path:join :dir libexec wut llvm lib) ^(String:split " " "-maxdepth 1 -name *.a -exec rm -f {} +") |>:complete

    # Delete headers, other than libc++ if present
    exec find (Path:join :dir libexec wut llvm include) ^(String:split " " "! -name c++ -mindepth 1 -maxdepth 1 -exec rm -rf {} +") |>:complete

    # Make a file in the toolchain that contains the host triple
    exec sh -c "echo ^(target-triple:host) > ^(Path:join :dir libexec wut host)" |>:complete

    # Create package info
    {
        target = match target-triple:host [
            x86_64-unknown-linux-gnu -> linux-x86_64
            aarch64-unknown-linux-gnu -> linux-aarch64
            x86_64-apple-macos -> macos-x86_64
            arm64-apple-macos -> macos-arm64
        ]
        fmt = String:from <| fs:read <| Path:join (source:dir ()) package.json
        package = String:format ^{ version, target } :fmt
        fs:create-dir (Path:join :dir info)
        fs:write (Path:join :dir info package.json) :package
    }
}

# Merge a directory into another directory
merge-dir = fn :src :dst -> (exec sh -c "cp -rf ^(:src)/* ^(:dst)" |>:complete)

# Archives a toolchain and installs it into the working directory
install-toolchain = fn :toolchain -> {
    [^_, :basename] = Path:split :toolchain
    dist = Path:join (source:dir ()) dist
    args = {
        pwd = Path:parent :toolchain
        env = { PATH = env:get PATH }
    }
    package = {
        fs:remove :dist
        fs:create-dir :dist
        upkg = wipal:fetch:upkg 0.6.1
        upkg:package :toolchain
    }
    fs:copy :package <| Path:join :dist (Path:name :package)
}

test-toolchain = fn (Path :toolchain) (Array:Of :String |> :targets) -> {
    test-target = fn (optional <| String :target) (Bool :use-clang-executable) -> {
        prefix-tool = fn (String :tool) -> fn ^:args -> {
            kwargs = {
                env = { PATH = "^(Path:join :toolchain bin):^(env:get PATH)" }
                pwd = Path:join (source:dir ()) test
            }
            prefix = match :target [
                :unset -> ""
                _ -> "^(:target)-"
            ]
            tool = "^(:prefix)^(:tool)"
            exec ^:kwargs :tool ^:args |>:complete
        }
        tool = fn :tool -> fn ^:args -> {
            kwargs = {
                env = { PATH = "^(Path:join :toolchain bin):^(env:get PATH)" }
                pwd = Path:join (source:dir ()) test
            }
            exec ^:kwargs :tool ^:args |>:complete
        }
        target = default :target as !target-triple:host

        cc = prefix-tool <| if :use-clang-executable clang else cc
        c++ = prefix-tool <| if :use-clang-executable clang++ else c++
        ld = prefix-tool ld
        ar = tool ar
        ranlib = tool ranlib

        # Skip strip on arm64e: https://bugs.llvm.org/show_bug.cgi?id=50044
        strip = match (target-triple:arch :target) [
            arm64e -> fn ^:args -> ()
            _ -> tool strip
        ]

        out = Path:new ()
        bar.o = Path:join :out bar.o
        bar.a = Path:join :out bar.a
        foo.o = Path:join :out foo.o
        foo-lib = match (target-triple:os target-triple:host) [
            macos -> Path:join :out libfoo.dylib
            linux -> Path:join :out libfoo.so
        ]
        test-c = Path:join :out test-c
        test-c++ = Path:join :out test-c++

        link-flags = match (target-triple:os target-triple:host) [
            macos -> [-dylib]
            linux -> [-shared]
        ]

        fs:create-dir :out

        build-flags = [-fPIC, -Werror, -Wall, -Wextra, -Wpedantic]

        # Build library
        cc ^:build-flags -c -o :bar.o bar.c
        cc ^:build-flags -c -o :foo.o foo.c
        ar rc :bar.a :bar.o
        ranlib :bar.a
        ld ^:link-flags -o :foo-lib :foo.o :bar.a
        strip --strip-all :foo-lib
  
        # Build C program
        cc ^:build-flags -o :test-c main.c :foo-lib
        strip --strip-all :test-c

        # Test C++ compiler
        c++ ^:build-flags -o :test-c++ main.cpp :foo-lib
        strip --strip-all :test-c++

        # Run tests (if correct target)
        run-tests = fn -> {
            kwargs = {
                env = {
                    LD_LIBRARY_PATH = :out
                    DYLD_LIBRARY_PATH = :out
                }
            }
            exec ^:kwargs :test-c |>:complete
            exec ^:kwargs :test-c++ |>:complete
        }
        match (by-content :target) [
            target-triple:host -> (run-tests)
            () -> (run-tests)
            _ -> ()
        ]
        ()
    }

    # test all available targets, as well as the default host target
    Iter:map (fn :target -> [test-target :target Bool:false, test-target :target Bool:true]) [^:targets, :unset]
}

{
    wipal
    build
    prepare-toolchain
    merge-dir
    target-triple
    llvm-version

    command = fn :cmd ^:args -> match :cmd [
        build -> {
            impl = ergo (target-triple:os target-triple:host)
            test-toolchain impl:toolchain impl:targets
            install-toolchain impl:toolchain
        }
        ct-ng -> {
            impl = ergo (target-triple:os target-triple:host)
            impl:ct-ng
        }
    ]
}
