std:import { by-content, cache, default, env, ergo-remote, exec, fs, if, match, net, optional, source, task } = std:
std:import { Array, Bool, Iter, Path, String } = std:

version = 3.0.0rc0

wipal = ergo wipal 0.8.1

# Step into the only directory in another directory
remove-top-dir = fn :dir -> {
    [:only] = fs:glob <| String:format "{}/*/" :dir
    :only
}

llvm-url = "https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0-rc3/llvm-project-13.0.0rc3.src.tar.xz"
Array:Of :Path |> :llvm-patches = Array:from <| Iter:map fs:track <| fs:glob "patches/*"
llvm-src = cache {
    dir = remove-top-dir <| task "Downloading LLVM" <| net:unarchive :llvm-url
    # sequentially apply patches
    ^Array:from <| Iter:map (fn :patch -> {
        exec ^{pwd = :dir} (env:path-search patch) -p1 -i :patch |>:complete
    }) :llvm-patches
    :dir
}

build = {
    cmake-project = fn :build-args -> cache {
        build = Path:new:
        install = Path:new:
        args = {
            env = { PATH = env:get PATH }
            pwd = :build
        }
        install-prefix = String:format "-DCMAKE_INSTALL_PREFIX={}" :install
        out = {
            fs:create-dir :build
            exec ^:args cmake build-args:src ^build-args:extra-flags :install-prefix "-DCMAKE_BUILD_TYPE=Release" |>:complete
            exec ^:args cmake --build :build -- -j4 |>:complete
            exec ^:args cmake -P cmake_install.cmake |>:complete
            :install
        }
        task (String:format "{}" build-args:message) :out
    }

    llvm = fn :message :llvm-projects :flags -> cache {
        projects = Iter:fold (fn :acc :v -> String:format "{}{};" :acc :v) "-DLLVM_ENABLE_PROJECTS=" :llvm-projects
        build-args = {
            src = Path:join :llvm-src llvm
            extra-flags = [
                ^:flags
                :projects
                "-DLLVM_TARGETS_TO_BUILD=X86;ARM;AArch64"
                "-DLLVM_ENABLE_ZLIB=FORCE_ON"
                "-DLLVM_INSTALL_BINUTILS_SYMLINKS=ON"
                "-DLLVM_INSTALL_CCTOOLS_SYMLINKS=ON"
            ]
            message = :message
        }
        cmake-project :build-args
    }

    compiler-rt = fn :message :flags -> cache {
        build-args = {
            src = Path:join :llvm-src compiler-rt
            extra-flags = :flags
            message = :message
        }
        cmake-project :build-args
    }

    openmp = fn :message :flags -> cache {
        build-args = {
            src = Path:join :llvm-src openmp
            extra-flags = :flags
            message = :message
        }
        cmake-project :build-args
    }
}

target-triple = {
    arch = fn :target -> (String:split - :target):0
    vendor = fn :target -> (String:split - :target):1
    os = fn :target -> (String:split - :target):2

    host = {
        triple = match env:os [
            linux -> String:format "{}-unknown-linux-gnu" env:arch
            macos -> String:format "{}-apple-macos" env:arch
        ]
 
        std:log:info <| String:format "Detected host triple: {}" :triple    
        
        :triple
    }
}

use-gcc-cmake-flags = fn :toolchain-dir :target -> {
    gcc-tool = fn :toolchain-dir :target :tool -> Path:join :toolchain-dir bin <| String:format "{}-{}" :target :tool
    [
        String:format "-DCMAKE_C_COMPILER={}" <| gcc-tool :toolchain-dir :target cc
        String:format "-DCMAKE_CXX_COMPILER={}" <| gcc-tool :toolchain-dir :target c++
    ]
}

# Make toolchain binary links to the appropriate implementation (either script or binary)
prepare-toolchain = fn :dir :targets -> {
    binaries-to-keep = [
        clang
        clang++
        clang-12
        ld.lld
        ld64.lld.darwinnew
        lld
        ar, llvm-ar
        ranlib, llvm-ranlib
        as, llvm-as 
        size, llvm-size
        nm, llvm-nm
        strip, llvm-strip
        objcopy, llvm-objcopy 
        objdump, llvm-objdump 
        c++filt, llvm-cxxfilt 
        addr2line, llvm-addr2line 
        symbolizer, llvm-symbolizer 
        strings, llvm-strings
        readelf, llvm-readelf 
        readobj, llvm-readobj
        install_name_tool, llvm-install-name-tool
        lipo, llvm-lipo
        clang-format 
        scan-build
        lldb
        lldb-server
    ]

    prefixed-tools = [
        clang
        clang++
        cc
        c++
        ld
    ]

    non-prefixed-tools = [
        lldb
        lldb-server
        clang-format 
        scan-build
        ar
        as 
        ranlib
        size
        nm
        strip
        objcopy
        objdump 
        c++filt 
        addr2line 
        strings
        readelf
        ^match target-vendor [
            apple -> [install_name_tool, lipo]
            _ -> []
        ]
    ]

    link = fn :source :target -> (exec ln -sf :source :target |>:complete)

    make-script-tools = fn :target -> {
        prefix = fn :file -> Path:join :dir bin (String:format "{}-{}" :target :file)
        Iter:map (fn :file -> link "../libexec/wut/tools.sh" (prefix :file)) :prefixed-tools
    }

    keep-binary-patterns = Iter:fold (fn :acc :v -> [^:acc, "!", -name, :v]) [] :binaries-to-keep

    # Delete unusued llvm binaries
    exec find (Path:join :dir libexec wut llvm bin) ^:keep-binary-patterns ^(String:split " " "-type f -exec rm -f {} +") |>:complete
    exec find (Path:join :dir libexec wut llvm lib) ^(String:split " " "-name *.a ! -name clang -exec rm -f {} +") |>:complete

    # Delete headers, other than libc++ if present
    exec find (Path:join :dir libexec wut llvm include) ^(String:split " " "! -name c++ -mindepth 1 -maxdepth 1 -exec rm -rf {} +") |>:complete

    # Link `as` because LLVM doesn't, for some reason
    link llvm-as <| Path:join :dir libexec wut llvm bin as

    # Link the various tools into the bin directory
    Iter:map :make-script-tools :targets
    Iter:map (fn :file -> link (String:format "{}-{}" target-triple:host :file) (Path:join :dir bin :file)) :prefixed-tools
    Iter:map (fn :file -> link (Path:join .. libexec wut llvm bin :file) (Path:join :dir bin :file)) :non-prefixed-tools

    # Make a file in the toolchain that contains the host triple
    exec sh -c (String:format "echo {} > {}" target-triple:host (Path:join :dir libexec wut host)) |>:complete

    # Create package info
    {
        target = match target-triple:host [
            x86_64-unknown-linux-gnu -> linux-x86_64
            x86_64-apple-macos -> macos-x86_64
        ]
        fmt = String:from <| fs:read <| Path:join (source:dir ()) package.json
        package = String:format ^{ version, target } :fmt
        fs:create-dir (Path:join :dir info)
        fs:write (Path:join :dir info package.json) :package
    }
}

# Merge a directory into another directory
merge-dir = fn :src :dst -> (exec sh -c (String:format "cp -rf {}/* {}" :src :dst) |>:complete)

# Archives a toolchain and installs it into the working directory
install-toolchain = fn :toolchain -> {
    [^_, :basename] = Path:split :toolchain
    dist = Path:join (source:dir ()) dist
    args = {
        pwd = Path:parent :toolchain
        env = { PATH = env:get PATH }
    }
    package = {
        fs:remove :dist
        fs:create-dir :dist
        upkg = wipal:fetch:upkg 0.3.4-rc0
        upkg:package :toolchain
    }
    fs:copy :package <| Path:join :dist (Path:name :package)
}

test-toolchain = fn (Path :toolchain) (Array:Of :String |> :targets) -> {
    test-target = fn (optional <| String :target) (Bool :use-clang-executable) -> {
        prefix-tool = fn (String :tool) -> fn ^:args -> {
            kwargs = {
                env = { PATH = String:format "{}:{}" (Path:join :toolchain bin) (env:get PATH) }
                pwd = Path:join (source:dir ()) test
            }
            prefix = match :target [
                :unset -> ""
                _ -> String:format "{}-" :target
            ]
            tool = String:format "{}{}" :prefix :tool
            exec ^:kwargs :tool ^:args |>:complete
        }
        tool = fn :tool -> fn ^:args -> {
            kwargs = {
                env = { PATH = String:format "{}:{}" (Path:join :toolchain bin) (env:get PATH) }
                pwd = Path:join (source:dir ()) test
            }
            exec ^:kwargs :tool ^:args |>:complete
        }
        target = default :target as !target-triple:host

        cc = prefix-tool <| if :use-clang-executable clang cc
        c++ = prefix-tool <| if :use-clang-executable clang++ c++
        ld = prefix-tool ld
        ar = tool ar
        ranlib = tool ranlib

        # Skip strip on arm64e: https://bugs.llvm.org/show_bug.cgi?id=50044
        strip = match (target-triple:arch :target) [
            arm64e -> fn ^:args -> ()
            _ -> tool strip
        ]

        out = Path:new:
        bar.o = Path:join :out bar.o
        bar.a = Path:join :out bar.a
        foo.o = Path:join :out foo.o
        foo-lib = match (target-triple:os target-triple:host) [
            macos -> Path:join :out libfoo.dylib
            linux -> Path:join :out libfoo.so
        ]
        test-c = Path:join :out test-c
        test-c++ = Path:join :out test-c++

        link-flags = match (target-triple:os target-triple:host) [
            macos -> [-dylib]
            linux -> [-shared]
        ]

        fs:create-dir :out

        build-flags = [-fPIC, -Werror, -Wall, -Wextra, -Wpedantic]

        # Build library
        cc ^:build-flags -c -o :bar.o bar.c
        cc ^:build-flags -c -o :foo.o foo.c
        ar rc :bar.a :bar.o
        ranlib :bar.a
        ld ^:link-flags -o :foo-lib :foo.o :bar.a
        strip --strip-all :foo-lib
  
        # Build C program
        cc ^:build-flags -o :test-c main.c :foo-lib
        strip --strip-all :test-c

        # Test C++ compiler
        c++ ^:build-flags -o :test-c++ main.cpp :foo-lib
        strip --strip-all :test-c++

        # Run tests (if correct target)
        run-tests = fn -> {
            kwargs = {
                env = {
                    LD_LIBRARY_PATH = :out
                    DYLD_LIBRARY_PATH = :out
                }
            }
            exec ^:kwargs :test-c |>:complete
            exec ^:kwargs :test-c++ |>:complete
        }
        match (by-content :target) [
            target-triple:host -> (run-tests)
            () -> (run-tests)
            _ -> ()
        ]
        ()
    }

    # test all available targets, as well as the default host target
    Iter:map (fn :target -> [test-target :target Bool:false, test-target :target Bool:true]) [^:targets, :unset]
}

{
    remove-top-dir
    build
    prepare-toolchain
    merge-dir
    target-triple

    command = fn :cmd ^:args -> match :cmd [
        build -> {
            impl = ergo (target-triple:os target-triple:host)
            test-toolchain impl:toolchain impl:targets
            install-toolchain impl:toolchain
        }
        ct-ng -> {
            impl = ergo (target-triple:os target-triple:host)
            impl:ct-ng
        }
    ]
}
