std:import { cache, env, exec, fs, net, source, task } = :std
std:import { Array, Iter, Map, Path, String } = :std

targets = [
    x86_64-unknown-linux-gnu
    aarch64-unknown-linux-gnu
    armv7-unknown-linux-gnueabihf
]

per-target = fn :f -> std:Map:from <| std:Iter:map (fn :i -> std:MapEntry:@ :i (f :i)) :targets

ct-ng-url="https://github.com/crosstool-ng/crosstool-ng/archive/d9c9bfcc8d207792d7d916e2fc1e4eef0041260d.tar.gz"
ct-ng-src = cache <| task "downloading crosstool-NG" <| net:unarchive ^enter :ct-ng-url

zlib-url="https://www.zlib.net/fossils/zlib-1.2.7.3.tar.gz"
zlib-src = cache <| task "downloading zlib" <| net:unarchive ^enter :zlib-url

# CMake flags for using a particular GCC toolchain
use-gcc-cmake-flags = fn (Path :toolchain-dir) (String :target) -> {
    gcc-tool = fn :tool -> Path:join :toolchain-dir bin "^(:target)-^(:tool)"
    [
        String:format "-DCMAKE_C_COMPILER={}" <| gcc-tool cc
        String:format "-DCMAKE_CXX_COMPILER={}" <| gcc-tool c++
        String:format "-DCMAKE_ASM_COMPILER={}" <| gcc-tool cc
        String:format "-DCMAKE_C_COMPILER_TARGET={}" :target
        String:format "-DCMAKE_CXX_COMPILER_TARGET={}" :target
        String:format "-DCMAKE_ASM_COMPILER_TARGET={}" :target
        String:format "-DCMAKE_FIND_ROOT_PATH={}" <| Path:join :toolchain-dir :target sysroot
    ]
}

# Build crosstool-NG
ct-ng = cache {
    args = {
        env = { PATH = env:get PATH }
        pwd = :ct-ng-src
    }
    out = {
        build-dir = Path:new ()
        install-dir = Path:new ()
        fs:create-dir :build-dir
        fs:create-dir :install-dir

        # Run this, since we aren't using a delivered version of crostool-NG
        exec ^:args ./bootstrap |>:complete

        exec ^:args sh ./configure "--prefix=^(:install-dir)" |>:complete
        exec ^:args make -j16 |>:complete
        exec ^:args make install |>:complete
        Path:join :install-dir bin ct-ng
    }
    task "building crosstool-NG" :out
}

# Build bootstrap GCC with crosstool-NG
gcc = {
    build = fn :target -> cache {
        config = "^(:target).config"
        config-source = !fs:track <| Path:join (source:dir ()) :config
        out = Path:new ()
        args = {
            env = { PATH = env:get PATH }
            pwd = :out
        }
        toolchain = {
            fs:create-dir <| Path:join :out tarballs
            fs:copy :config-source (Path:join :out ".config")
            exec ^:args :ct-ng build.16 |>:complete
            Path:join :out toolchain
        }
        task "building gcc (^(:target))" :toolchain
    }
    per-target :build
}

# Build zlib for target, using bootstrap toolchain
zlib = {
    build = fn :target -> {
        build-args = {
            src = :zlib-src
            extra-flags = use-gcc-cmake-flags gcc::target :target
            message = "building zlib (^(:target))"
        }
        workspace:build:cmake-project :build-args
    }
    per-target :build
}

# Assemble bootstrap toolchain containing zlib
gcc-with-deps = {
    build = fn :target -> cache {
        out = Path:new ()
        toolchain = {
            fs:copy gcc::target :out
            workspace:merge-dir zlib::target <| Path:join :out :target sysroot usr
            :out
        }
        task "assembling bootstrap toolchain (^(:target))" :toolchain
    }
    per-target :build
}

# Build LLVM with bootstrap toolchain
llvm = {
    String :host = workspace:target-triple:host
    workspace:build:llvm "building LLVM" [clang, lld, lldb, clang-tools-extra] [
        ^(use-gcc-cmake-flags gcc-with-deps::host :host)
        "-DLLVM_STATIC_LINK_CXX_STDLIB=ON"
        "-DLLVM_INCLUDE_DOCS=OFF"
        "-DLLVM_INCLUDE_TESTS=OFF"
        "-DLLVM_INCLUDE_EXAMPLES=OFF"
        "-DLLVM_ENABLE_TERMINFO=OFF"

        # Would like to use these options, but for now they break the compiler-rt build.
        #"-DLLVM_BUILD_LLVM_DYLIB=ON"
        #"-DLLVM_LINK_LLVM_DYLIB=ON"

        "-DLLDB_ENABLE_PYTHON=OFF"
        "-DLLDB_ENABLE_LIBEDIT=OFF"
        "-DLLDB_ENABLE_CURSES=OFF"
    ]
}

# Build compiler-rt
compiler-rt = {
    build = fn :target -> cache {
        workspace:build:compiler-rt "building compiler-rt (^(:target))" [
            # We are not using LLVM's builtins
            "-DCOMPILER_RT_BUILD_BUILTINS=OFF"

            # Required for cross-compiling out-of-tree
            String:format "-DLLVM_CONFIG_PATH={}" <| Path:join :llvm bin llvm-config
            "-DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON"
            "-DCOMPILER_RT_USE_LIBCXX=OFF"

            # Cross-compile using clang
            String:format "-DCMAKE_AR={}" <| Path:join :llvm bin llvm-ar
            String:format "-DCMAKE_NM={}" <| Path:join :llvm bin llvm-nm
            String:format "-DCMAKE_RANLIB={}" <| Path:join :llvm bin llvm-ranlib
            String:format "-DCMAKE_LINKER={}" <| Path:join :llvm bin ld.lld
            String:format "-DCMAKE_OBJCOPY={}" <| Path:join :llvm bin llvm-objcopy
            String:format "-DCMAKE_SYSROOT={}" <| Path:join gcc-with-deps::target :target sysroot
            String:format "-DCMAKE_C_COMPILER={}" <| Path:join :llvm bin clang
            String:format "-DCMAKE_CXX_COMPILER={}" <| Path:join :llvm bin clang++
            String:format "-DCMAKE_ASM_COMPILER={}" <| Path:join :llvm bin clang
            String:format "-DCMAKE_C_COMPILER_TARGET={}" :target
            String:format "-DCMAKE_CXX_COMPILER_TARGET={}" :target
            String:format "-DCMAKE_ASM_COMPILER_TARGET={}" :target
            String:format "-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN={}" gcc-with-deps::target
            String:format "-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN={}" gcc-with-deps::target
            String:format "-DCMAKE_ASM_COMPILER_EXTERNAL_TOOLCHAIN={}" gcc-with-deps::target
            String:format "-DCMAKE_ASM_FLAGS=--target={}" :target
            "-DCMAKE_DYNAMIC_LINKER_FLAGS=-fuse-ld=lld"
            "-DCMAKE_EXE_LINKER_FLAGS=-fuse-ld=lld"

            # Workaround for GNU libstdc++
            "-DCMAKE_CXX_FLAGS=-D__STDC_FORMAT_MACROS=1"

            # Workaround for https://gitlab.kitware.com/cmake/cmake/-/issues/22995
            "-DCMAKE_ASM_COMPILER_VERSION=^(workspace:llvm-version)"

            # Workaround for https://github.com/llvm/llvm-project/issues/57717
            "-DCOMPILER_RT_BUILD_GWP_ASAN=OFF"
        ]
    }
    per-target :build
}

# Build OpenMP
openmp = {
    build = fn :target -> cache {
        workspace:build:openmp "building openmp (^(:target))" [
            String:format "-DLLVM_DIR={}" <| Path:join :llvm lib cmake llvm
            "-DOPENMP_ENABLE_LIBOMPTARGET=OFF"
            "-DLIBOMP_ENABLE_SHARED=OFF"
            "-DLIBOMP_CXXFLAGS=-fPIC -fvisibility=hidden -fvisibility-inlines-hidden"
            ^(use-gcc-cmake-flags gcc-with-deps::target :target)
        ]
    }
    per-target :build
}

# Delete remnants of GCC build
delete-unused-gcc-components = fn :dir -> {
    delete-target = fn :target -> {
        fs:remove <| Path:join :dir :target build.log.bz2
        fs:remove <| Path:join :dir :target bin
        fs:remove <| Path:join :dir :target libexec
        fs:remove <| Path:join :dir :target :target bin
    }
    per-target :delete-target
}

map-seq = fn (Map :m) -> {
    ^Array:from <| Iter:map (fn :e -> e:value) :m
    :m
}

# Assemble the toolchain
{
    toolchain = {
        dir = Path:new ()
        fs:create-dir <| Path:join :dir libexec wut gcc
        fs:create-dir <| Path:join :dir bin
        per-target (fn :target -> fs:copy gcc-with-deps::target (Path:join :dir libexec wut gcc :target))
        fs:copy :llvm (Path:join :dir libexec wut llvm)
        delete-unused-gcc-components <| Path:join :dir libexec wut gcc
        workspace:prepare-toolchain :dir :targets

        # Write sequentially to avoid a race condition in `cp`
        map-seq <| per-target <| fn :target -> {
            workspace:merge-dir compiler-rt::target <| Path:join :dir libexec wut llvm lib clang workspace:llvm-version
            workspace:merge-dir openmp::target <| Path:join :dir libexec wut gcc :target :target sysroot
        }
        :dir
    }

    ct-ng = :ct-ng

    targets
}
